#+TITLE: Real World OCaml Notes
#+AUTHOR: Andrew Jarrett
#+DATE: <2018-09-22 Sat>


* Getting Everything Set up & Installed

The instructions in the book are dated, so I used [[https://dev.realworldocaml.org/install.html][this tutorial]] to get OCaml, the package manager, and a number of libraries set up and installed for working through the book.

** Core

When trying to evaluate =open Core.Std;;= in utop (like the book recommends), you'll crash headfirst into =Unbound module Core=.

Make sure you've installed core.

=$ opam install Core=

Then in utop you can do:

=# #require "Core";;=

Note that the second =#= is not part of the prompt, but part of what you type in. Afterwards you can do:

=# open Core;;=

And you're good to start using Core.

** Other libraries:

While we're at it, let's just install everything we'll need for the book:

=$ opam install async yojson core_extended core_bench cohttp async_graphics cryptokit menhir=

Installs:

- opam 
- install 
- async 
- yojson 
- core_extended 
- core_bench 
- cohttp 
- async_graphics 
- cryptokit 
- menhir





* Chapter 1: A Guided Tour

[[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter1][Chapter 1 Exercises & Projects Here]]

p.3

#+BEGIN_QUOTE
Throughout the book we’re going to use Core, a more full-featured and capable re‐ placement for OCaml’s standard library. 
#+END_QUOTE

** OCaml as a Calculator

Using Core:

#+BEGIN_SRC ocaml
  $ utop
  # open Core;; (* book says `open Core.std;;`, but this looks to be defunct *)
#+END_SRC

A note on =;;=:

#+BEGIN_QUOTE
We needed to type ;; in order to tell the toplevel that it should evaluate an expres‐ sion. This is a peculiarity of the toplevel that is not required in standalone programs (though it is sometimes helpful to include ;; to improve OCaml’s error reporting, by making it more explicit where a given top-level declaration was intended to end).
#+END_QUOTE

A note on underscores in numbers:

#+BEGIN_QUOTE
OCaml allows you to place underscores in the middle of numeric literals to improve readability.
#+END_QUOTE

Example:

=30_000_000 / 300_000=

On syntax for /let bindings/:

#+BEGIN_QUOTE
Punctuation is excluded, except for _ and ', and variables must start with a lowercase letter or an underscore
#+END_QUOTE

** Functions & Type Inference

The let syntax can also be used to define a function.

Looking at types, briefly:

#+BEGIN_SRC ocaml
  # let ratio x  y=
  Float.of_int x /. Float.of_int y
  ;;
  val ratio : int -> int -> float = <fun> # ratio 4 7;;
  - : float = 0.571428571429
#+END_SRC

Here we use the Float module. Note that module names always start with a capital letter.

Because functions are first-class in OCaml, we can pass functions as arguments:

#+BEGIN_SRC ocaml :exports both
  let sum_if_true test first second =
    (if test first then first else 0)
    + (if test second then second else 0)
  ;;  (* val sum_if_true : (int -> bool) -> int -> int -> int = <fun> *)

  let even x =
    x mod 2 = 0;;

  sum_if_true even 8 4;;          (* 12 *)

  sum_if_true even 3 2;;          (* 2 *)
#+END_SRC

#+RESULTS:
: 2

Look how it inferred the type of our =test= function! So cool.

** Type inference

How did it infer that =sum_if_true= took a function of type (int -> bool)?

OCaml requires that both branches of an if statement have the same type:

#+BEGIN_QUOTE
OCaml requires that both branches of an if statement have the same type, so the expression if test first then first else 0 requires that first must be the same type as 0, and so first must be of type int.
#+END_QUOTE

To help with getting an intuition for this, let's annotate sum_if_true:

#+BEGIN_SRC ocaml :exports both
let sum_if_true (test : int -> bool) (x : int) (y : int) : int =
  (if test x then x else 0)
  + (if test y then y else 0) ;;
#+END_SRC

#+RESULTS:
: val sum_if_true : (int -> bool) -> int -> int -> int = <fun>

** Inferring Generic Types

Sometimes there isn't enough info to infer a variable's type, for example:

#+BEGIN_SRC ocaml :exports both
let first_if_true test x y =
  if test x then x else y;;
#+END_SRC

#+RESULTS:
: val first_if_true : ('a -> bool) -> 'a -> 'a -> 'a = <fun>

OCaml has introduced a *type variable* \'a to express that the type is generic. This kind of genericity is called *parametric polymorphism*.

#+BEGIN_QUOTE
Whatever type 'a is, it has to be the same as the type of the other two arguments, x and y, and of the return value of firstiftrue. This kind of genericity is called parametric polymorphism because it works by parameterizing the type in question with a type variable
#+END_QUOTE

#+BEGIN_SRC ocaml :exports both
let first_if_true test x y =
  if test x then x else y;;

let long_string s = String.length s > 6;;

first_if_true long_string "short" "lonnnnnng";;
#+END_SRC

#+RESULTS:
: lonnnnnng

We can use =first_if_true= with ints, too:

#+BEGIN_SRC ocaml :exports both
let big_number x = x > 3;;

first_if_true big_number 4 3;;
#+END_SRC

#+RESULTS:
: 4

** Type Errors Versus Exceptions

Big difference is that (usually) type errors are encountered at compile time, and exceptions occur at run time.

Exceptions occur for things the compiler can't check, for example division by zero.

#+BEGIN_SRC ocaml :exports both
let is_a_multiple x y = x mod y = 0 ;;
val is_a_multiple : int -> int -> bool = <fun> # is_a_multiple 8 2;;
is_a_multiple 8 0;;
#+END_SRC

#+RESULTS:
: Exception: Division_by_zero.

** Tupes, Lists, Options & Pattern Matching

*** Tuples

You can create a tuple by joining values together with a comma:

#+BEGIN_SRC ocaml :exports both
let a_tuple = (3,"three");;
#+END_SRC

#+RESULTS:
: val a_tuple : int * string = (3, "three")

What's going on with the asterisk?

#+BEGIN_QUOTE
(For the mathematically inclined, the * character is used because the set of all pairs of type t * s corresponds to the Cartesian product of the set of elements of type t and the set of elements of type s.)
#+END_QUOTE

You can extract the components of a tuple using OCaml’s pattern-matching syntax:

=let (x,y) = a_tuple;;=

/Note that the same syntax is used both for constructing and for pattern matching on tuples./

We can also take advantage of pattern matching in function arguments:

#+BEGIN_SRC ocaml :exports both
  let distance (x1,y1) (x2,y2) =
    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) **2.)
#+END_SRC

#+RESULTS:
: val distance : float * float -> float * float -> float = <fun>

The =**= operator used above is for raising a floating-point number to a power.

*** Lists

Lists let you hold any number of items of the same type

#+BEGIN_SRC ocaml :exports both
  let languages = ["OCaml"; "Clojure"; "JavaScript"]

  let numbers = [3; "four"; 5]
#+END_SRC

**** The List module

Core comes with a =List= module:

#+BEGIN_SRC ocaml
  Open Core;;

  List.length languages;;                 (* int = 3 *)

  List.map languages ~f:String.length;;   (* int list = [4; 7; 10] *)
#+END_SRC

=List.map= takes a list and a function. Notice how we use a *labelled argument*, in this case =~f=. /Labelled arguments are specified by name/, rather than by position.

So we could also have done:

=List.map ~f:String.length languages=

**** Constructing lists with =::=

We can use the =::= operator for adding elements to the front of a list.

#+BEGIN_SRC ocaml
  "French" :: "Cantonese" :: languages
  (* : string list = ["French"; "Spanish"; "OCaml"; "Clojure"; "JavaScript"] *)
#+END_SRC

*Note:* We separate values in a list with /semicolons/ instead of commas. Commas are for separating elements in a tuple.

If we forget and use commas, we get something different that we expect:

#+BEGIN_SRC ocaml :exports both
  ["OCaml", "Perl", "C"];;
#+END_SRC

#+RESULTS:
: - : (string * string * string) list = [("OCaml", "Perl", "C")]

It's a list of tuples of type =(string * string * string)=.

This is because /commas create a tuple even if there are no surrounding parens/.

The bracket notation is just syntactic sugar for =::=.

=::= only adds 1 element to the list. What about list concatenation?

There’s a list concatenation operator, =@=, which can concatenate two lists:

#+BEGIN_SRC ocaml :exports both
  [1;2;3]@[4;5;6]

#+END_SRC

#+RESULTS:
: - : int list = [1; 2; 3; 4; 5; 6]

*List concat time complexity*: =@= is not constant-time. Concatting two lists takes time /proportional to the length of the first list/.

**** List patterns using match

We can use pattern matching to access elements of a list.

#+BEGIN_SRC ocaml :exports both
  let my_fav_lang (my_fav :: the_rest) =
    my_fav
#+END_SRC

#+RESULTS:
: Characters 16-47:
:   ................(my_fav :: the_rest) =
:     my_fav..
: Warning 8: this pattern-matching is not exhaustive.
: Here is an example of a case that is not matched:
: []
: val my_fav_lang : 'a list -> 'a = <fun>

Notice that we get a warning that our matching is not exhaustive! Let's take care of that by using a =match= statement.

#+BEGIN_QUOTE
(Pattern matching) essentially lets you list a sequence of patterns, separated by pipe characters (|). (The one before the first case is optional.)
#+END_QUOTE

#+BEGIN_SRC ocaml :exports true
  let languages = ["French"; "Spanish"; "OCaml"; "Clojure"; "JavaScript"]

  let my_fav_lang languages =
    match languages with
    | first :: the_rest -> first
    | [] -> "OCaml";;
#+END_SRC

#+RESULTS:
: val languages : string list =
:   ["French"; "Spanish"; "OCaml"; "Clojure"; "JavaScript"]
: val my_fav_lang : string list -> string = <fun>

#+BEGIN_SRC ocaml :exports true
my_fav_lang languages;;
#+END_SRC

#+RESULTS:
: French

#+BEGIN_SRC ocaml :exports both
my_fav_lang [];;
#+END_SRC

#+RESULTS:
: OCaml

**** Recursive list functions

Use the =rec= keyword after let to tell the compiler that this is a recursive function.

#+BEGIN_QUOTE
The typical approach to designing a recursive function is to separate the logic into a set of base cases that can be solved directly and a set of inductive cases, where the function breaks the problem down into smaller pieces and then calls itself to solve those smaller problems.
#+END_QUOTE

When writing recursive list functions, this separation between the base cases and the inductive cases is often done using pattern matching.

#+BEGIN_SRC ocaml :exports both
  let rec sum l =
    match l with
    | [] -> 0
    | hd::tl -> hd + sum tl;;

  sum [1;2;3;4;5];;
#+END_SRC

#+RESULTS:
: 15

Here's a function for removing sequential duplicates:

#+BEGIN_SRC ocaml :exports both
  let rec destutter list =
    match list with
    | [] -> []
    | hd1 :: hd2 :: tl ->
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl);;
#+END_SRC

#+RESULTS:
#+begin_example
Characters 27-161:
  ..match list with
    | [] -> []
    | hd1 :: hd2 :: tl ->
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)....
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::[]
val destutter : 'a list -> 'a list = <fun>
#+end_example

Why are we getting this warning message? Because we're not handling the 1-element list case.

#+BEGIN_SRC ocaml :exports both
  let rec destutter list =
    match list with
    | [] -> []
    | [hd] -> [hd]  (* This is different than SML, I think... *)
    | hd1 :: hd2 :: tl ->
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl);;
#+END_SRC

#+RESULTS:
: val destutter : 'a list -> 'a list = <fun>

Let's use it:

#+BEGIN_SRC ocaml :exports both
destutter ["yo";"yo";"ma"];;
#+END_SRC

#+RESULTS:
: - : string list = ["yo"; "ma"]

Note that this code used another variant of the list pattern, [hd], to match a list with a single element. We can do this to match a list with any fixed number of elements; for example, [x;y;z] will match any list with exactly three elements and will bind those elements to the variables x, y, and z.

**** Options

*** Options

An option is used to express that a value might or might not be present.

#+BEGIN_SRC ocaml 
  let divide x y =
    if y = 0 then None else Some(x/y);;
  (* val divide : int -> int -> int option = <fun> *)

  let log_entry maybe_time message =
    let time =
      match maybe_time with
      | Some x -> x
      | None -> Time.now()
    in
    Time.to_sec_string time ^ " -- " ^ message;;
  (* val log_entry : Time.t option -> string -> string = <fun> *)

  log_entry (Some Time.epoch) "A long long time ago";;
  (* string = "1970-01-01 01:00:00 -- A long long time ago" *)

  log_entry None "Up to the minute";;
  (* string = "2013-08-18 14:48:08 -- Up to the minute" *)
#+END_SRC


This example uses Core’s Time module for dealing with time, as well as the ^ operator for concatenating strings. /The concatenation operator is provided as part of the Pervasives module/, which is automatically opened in every OCaml program.

#+BEGIN_QUOTE
Options are important because they are the standard way in OCaml to encode a value that might not be there; there’s no such thing as a =NullPointerException= in OCaml
#+END_QUOTE

A value of type =string * string= always contains two well-defined values of type string. If you want to allow, say, the first of those to be absent, then you need to change the type to =string option * string=.

*** Records & Variants

We can also define our own data types. For example:

#+BEGIN_SRC ocaml :exports both
  type point2d = { x : float; y : float };;
#+END_SRC

#+RESULTS:
: type point2d = { x : float; y : float; }

=point2d= is a *record* type, which is like a tuple where the fields are named instead of being defined positionally.

We can get the contents of a record using pattern matching:

#+BEGIN_SRC ocaml :exports both
  let magnitude { x = x_pos; y = y_pos } =
    sqrt (x_pos ** 2. +. y_pos ** 2.);;
#+END_SRC

#+RESULTS:
: val magnitude : point2d -> float = <fun>

Look at that! The interpreter figured out that the argument to magnitude is point2d, our custom type!

We can write this more tersely using *field punning*. We could simply have done:

=let magnitude { x; y } = ...=

We can also use dot notation for accessing record fields:

#+BEGIN_SRC ocaml :exports both
  let distance v1 v2 =
    magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };;
#+END_SRC

#+RESULTS:
: val distance : point2d -> point2d -> float = <fun>

Let's make some more custom types:

#+BEGIN_SRC ocaml :exports both
  type circle_desc = { center: point2d; radius: float }
  type rect_desc   = { lower_left: point2d; width: float; height: float }
  type segment_desc = { endpoint1: point2d; endpoint2: point2d };;
#+END_SRC

#+RESULTS:
: type circle_desc = { center : point2d; radius : float; }
: type rect_desc = { lower_left : point2d; width : float; height : float; }
: type segment_desc = { endpoint1 : point2d; endpoint2 : point2d; }

Now let's combine some of these together into a *variant type*:

#+BEGIN_SRC ocaml :exports both
  type scene_element =
    | Circle  of circle_desc
    | Rect    of rect_desc
    | Segment of segment_desc
  ;;
#+END_SRC

#+RESULTS:
: type scene_element =
:     Circle of circle_desc
:   | Rect of rect_desc
:   | Segment of segment_desc

The pipe character separates the different cases of the variant. Note that /each case has a capitalized tab/.

#+BEGIN_SRC ocaml :exports both
  let is_inside_scene_element point scene_element =
    match scene_element with
    | Circle { center; radius } ->
      distance center point < radius
    | Rect { lower_left; width; height } ->
      point.x    > lower_left.x && point.x < lower_left.x +. width
      && point.y > lower_left.y && point.y < lower_left.y +. height
    | Segment { endpoint1; endpoint2 } -> false
  ;;
#+END_SRC

#+RESULTS:
: val is_inside_scene_element : point2d -> scene_element -> bool = <fun>

Now let's test our cool function:

#+BEGIN_SRC ocaml
  let is_inside_scene point scene =
    List.exists scene
      ~f:(fun el -> is_inside_scene_element point el)
  ;;
  (* val is_inside_scene : point2d -> scene_element list -> bool = <fun> *)

  is_inside_scene {x=3.;y=7.}
    [ Circle {center = {x=4.;y= 4.}; radius = 0.5 } ];;
  (* : bool = false *)

  is_inside_scene {x=3.;y=7.}
    [ Circle {center = {x=4.;y= 4.}; radius = 5.0 } ];;
  (* : bool = true *)
#+END_SRC

[[https://stackoverflow.com/questions/4513910/how-to-access-a-list-in-ocaml][List.exists discussed on Stack Overflow]]. It seems to be part of the Core library.

The exists function will return true if any element in the list satisfies the predicate (the function). Reminds me of the =Array.prototype.some= function in JS.

We also made our first use of an anonymous function in the call to List.exists using the =fun= keyword and the =->= arrow after the arguments.

** Imperative Programming

OCaml has data structures that are mutable, too.

*** Arrays

Indexes start at 0; accessing or modifying an array element happens in /contant time/.

#+BEGIN_SRC ocaml :exports both
  let numbers=[| 1;2;3;4 |];;
#+END_SRC

#+RESULTS:
: val numbers : int array = [|1; 2; 3; 4|]

Now we can mutate the array:

#+BEGIN_SRC ocaml :exports both
  numbers.(2) <- 4;;
  (* : unit = () *)

  numbers;;
#+END_SRC

#+RESULTS:
: - : int array = [|1; 2; 4; 4|]

The =.(i)= syntax is used to refer to an element of the array, and the =<-= syntax is for modification/mutation.

On =unit=:

#+BEGIN_QUOTE
The unit type that we see in the preceding code is interesting in that it has only one possible value, written (). This means that a value of type unit doesn’t convey any information, and so is generally used as a placeholder. Thus, we use unit for the return value of an operation like setting a mutable field that communicates by side effect rather than by returning a value.
#+END_QUOTE

*** Mutable Record Fields

Records are immutable by default, but some of their fields can be explicitly declared to be mutable.

#+BEGIN_SRC ocaml :exports both
  type running_sum =
    { mutable sum: float;
      mutable sum_sq: float;      (* sum of squares *)
      mutable samples: int;
    }
  ;;

  let mean rsum = rsum.sum /. float rsum.samples let stdev rsum =
       sqrt (rsum.sum_sq /. float rsum.samples
             -. (rsum.sum /. float rsum.samples) ** 2.) ;;
#+END_SRC

#+RESULTS:
: val mean : running_sum -> float = <fun>
: val stdev : running_sum -> float = <fun>

Notice the function =float=, which is a convenient equivalent to =Float.of_int= and is provided by the =Pervasives= library.

We need functions to create an update =running_sums=:

#+BEGIN_SRC ocaml :exports both
  let create () = { sum=0.; sum_sq=0.; samples=0 }
  let update rsum x =
    rsum.samples <- rsum.samples + 1;
    rsum.sum     <- rsum.sum     +. x;
    rsum.sum_sq  <- rsum.sum_sq  +. x *. x
  ;;
#+END_SRC

#+RESULTS:
: val create : unit -> running_sum = <fun>
: val update : running_sum -> float -> unit = <fun>

Note the use of single semicolons to sequence operations. When we were working purely functionally, this wasn’t necessary, but you start needing it when you’re writing imperative code.

Let's mutate!

#+BEGIN_SRC ocaml
  let rsum = create ();;
  (* val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0} *)

  List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -> update rsum x);;
  (* unit = () *)

  mean rsum;;
  (* float = 1.33333333333 *)

  stdev rsum;;
  (* float = 3.94405318873 *)
#+END_SRC

*** Refs

We create a single mutable value by using a =ref=. A =ref= is a record type with a single mutable field called =contents=:

#+BEGIN_SRC ocaml :exports both
  let x = { contents = 0 };;
  (* val x : int ref = {contents = 0} *)

  x.contents <- x.contents + 1;;
  (* unit = () *)

  x;;
#+END_SRC

#+RESULTS:
: - : int ref = {contents = 1}

There are some useful functions and operators to make =refs= more convenient to work with:

=let x = ref 0= means create a ref with contents = 0
=!x= means get the contents of a ref, i.e. x.contents
=x \:\\=\ !x+1 means assignment, i.e. x.contents <- ...

The =ref= type is simple; we can completely reimplement it:

#+BEGIN_SRC ocaml :exports both
  type 'a ref = { mutable contents : 'a }

  let ref x = { contents = x }
  let (!) r = r.contents
  let (:=) r x = r.contents <- x
  ;;
#+END_SRC

#+RESULTS:
: type 'a ref = { mutable contents : 'a; }
: val ref : 'a -> 'a ref = <fun>
: val ( ! ) : 'a ref -> 'a = <fun>
: val ( := ) : 'a ref -> 'a -> unit = <fun>

The 'a before the ref indicates that the ref type is polymorphic, in the same way that lists are polymorphic, meaning it can contain values of any type. The parentheses around ! and := are needed because these are operators, rather than ordinary functions.

*** For and While Loops

We use the Random module as a source of randomness and permuate an array with a for loop:

#+BEGIN_SRC ocaml
  let permute array =
    let length = Array.length array in
    for i = 0 to length - 2 do
      (* pick a `j` to swap with *)
      let j = i + Random.int (length - i) in
      (* swap `i` and `j` *)
      let tmp = array.(i) in
      array.(i) <- array.(j);
      array.(j) <- tmp
    done
  ;;

  let ar = Array.init 10 ~f:(fun i -> i);;
  permute ar;;
  (* [|3; 9; 1; 6; 4; 2; 5; 8; 7; 0|] *)
#+END_SRC

From a syntactic perspective, you should note the keywords that distinguish a for loop:

=for=, =to=, =do=, and =done=.

Let's look at =while= loops.

#+BEGIN_SRC ocaml :exports both
  let find_first_negative_entry arr =
    let pos = ref 0 in
    while !pos < Array.length arr && arr.(!pos) >= 0 do
      pos := !pos + 1
    done;
    if !pos = Array.length arr then None else Some !pos
  ;;
#+END_SRC

#+RESULTS:
: val find_first_negative_entry : int array -> int option = <fun>

#+BEGIN_SRC ocaml :exports both
  find_first_negative_entry [| 0;1;2;3;4;5;3 |];;
#+END_SRC

#+RESULTS:
: - : int option = None

#+BEGIN_SRC ocaml :exports both
  find_first_negative_entry [| 1;3;-5;10;95;-4 |];;
#+END_SRC

#+RESULTS:
: - : int option = Some 2

As a side note, the preceding code takes advantage of the fact that &&, OCaml’s And operator, short-circuits. In particular, in an expression of the form expr1 && expr2, expr2 will only be evaluated if expr1 evaluated to true /(just like JS)/.

Notice how, when we change the code, we get an out of bounds error:

#+BEGIN_SRC ocaml :exports both
  let find_first_negative_entry array =
    let pos = ref 0 in
    while
      let pos_is_good = !pos < Array.length array in
      let element_is_non_negative = array.(!pos) >= 0 in
      pos_is_good && element_is_non_negative
    do
      pos := !pos + 1
    done;
    if !pos = Array.length array then None else Some !pos
  ;;

  let arr = [|1;2;0;3|];;
  find_first_negative_entry arr;;
#+END_SRC

#+RESULTS:
: Exception: Invalid_argument "index out of bounds".

The or operator =||= short circuits as well.


** A Complete Program

Let's create a standalone program now. This program will sum up a list of numbers read in from standard input.

The program is contained in [[file:sum.ml][sum.ml]] (located in this repository).

#+BEGIN_SRC ocaml
  #require "Core";;
  open Core;;

  let rec read_and_acc acc =
    let line = In_channel.input_line In_channel.stdin in
    match line with
    | None -> acc
    | Some x -> read_and_acc (acc +. Float.of_string x)

  let () =
    printf "Total: %F\n" (read_and_acc 0.)
#+END_SRC

*** Compiling and Running

We compile with =corebuild=, a small wrapper on top of /jbuilder/, a build tool that ships with the OCaml compiler.

It comes installed with Core.

=$ corebuild sum.native=

The =.native= suffix indicates that we're building a native-code executable (see Chapter 4). It creates a file in the same directory called =sum.native=.

This file is executable; to run it do =./sum.native=.


* Chapter 2: Variables & Functions

[[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter2][Chapter 2 Exercises & Projects Here]]

** Variables

#+BEGIN_QUOTE
Every variable binding has a scope, which is the portion of the code that can refer to that binding. When using utop, the scope of a top-level let binding is everything that follows it in the session. When it shows up in a module, the scope is the remainder of that module.
#+END_QUOTE

let can also be used to create a variable binding whose scope is limited to a particular expression, using the following syntax:

=let <variable> = <expr1> in <expr2>=

Let's practice:

#+BEGIN_SRC ocaml
  let languages = "OCaml,JavaScript,Brainfuck,C";;

  let dashed_langs =
    let languages = String.split languages ~on:',' in
    String.concat ~seq:"-" languages
  ;;

  dashed_langs;;
  (* val dashed_langs : string = "OCaml-Perl-C++-C" *)
#+END_SRC

Notice how =languages= inside =dashed_langs= is different than it is outside the expression.

A let binding in an inner scope can *shadow*, or /hide/, the definition from an outer scope.

*** Pattern Matching and =let=

=let= bindings support the use of /patterns/ on the lefthand side.

#+BEGIN_SRC ocaml
  let (ints, strings) =
    List.unzip [(1,"one"); (2,"two"); (3,"three")];;

  (* val ints : int list = [1; 2; 3]
   ,* val strings : string list = ["one"; "two"; "three"] *)
#+END_SRC

=List.unzip= converts a list of tuple pairs into a pair of lists.

A /pattern/ is essentially a description of the shape of a data structure, where some components are identifiers to be bound.

Using a pattern in a let binding makes the most sense for a pattern that is /irrefutable/, i.e., where any value of the type in question is guaranteed to match the pattern. Tuple and record patterns are irrefutable, /but list patterns are not/.

Therefore with lists we =match= to find patterns, instead of destructuring (is this true? my own interpretation).

#+BEGIN_SRC ocaml
  let upcase_first_entry line =
    match String.split ~on:',' line with
    | [] -> assert false (* String.split returns at least one element *)
    | first :: rest -> String.concat ~sep:"," (String.uppercase first :: rest)
  ;;
  (* val upcase_first_entry : string -> string = <fun> *)
#+END_SRC

** Functions

*** Anonymous Functions

An anonymous function is a function that is declared without being named. These can be declared using the fun keyword.

=(fun x -> x + 1) 7;;=
=:  int = 8=

We can pass them to other functions.

#+BEGIN_SRC ocaml
  List.map ~f:(fun x -> x + 1) [1;2;3];;
  (* - : int list = [2; 3; 4] *)
#+END_SRC

We can put them in data structures (I love this example).

#+BEGIN_SRC ocaml :exports both
  let increments = [ (fun x -> x + 1); (fun x -> x + 2) ];;
  (* whoa *)
  List.map ~f:(fun g -> g 5) increments;;
#+END_SRC

#+RESULTS:
: Characters 23-37:
:   List.map ~f:(fun g -> g 5) increments;;;;
:               ^^^^^^^^^^^^^^
: Error: The function applied to this argument has type 'a list -> 'b list
: This argument cannot be applied with label ~f

*Note:* Functions and let bindings have a lot to do with each other.

#+BEGIN_QUOTE
In some sense, you can think of the parameter of a function as a variable being bound to the value passed by the caller...

This connection is important, and will come up more when programming in a monadic style, as we’ll see in Chapter 18.
#+END_QUOTE

Example:
=(fun x -> x + 1) 7;;= 
=let x = 7 in x + 1;;=

In both cases, x is 8.

*** Multiargument functions

Don't forget that they're curried, which is why you get type signatures like this: =int -> int -> int=

#+BEGIN_SRC ocaml :exports both
  let abs_diff x y = abs (x - y);;
#+END_SRC

#+RESULTS:
: val abs_diff : int -> int -> int = <fun>

The practice of applying some of the arguments of a curried function to get a new function is called /partial application/.

But is it slow?

#+BEGIN_QUOTE
You might worry that curried functions are terribly expensive, but this is not the case. In OCaml, there is no penalty for calling a curried function with all of its arguments. (Partial application, unsurprisingly, does have a small extra cost.)
#+END_QUOTE

We could rewrite the function above like this, and partial application won't work because the function expects a tuple:

=let abs_diff (x,y) = abs (x - y);;=

*** Recursive Functions

In order to define a recursive function, you need to mark the let binding as recursive with the =rec= keyword.

#+BEGIN_SRC ocaml :exports both
  let rec find_first_stutter list =
    match list with
    | [] | [_] -> None
    | x :: y :: tl ->
      if x = y then Some x else find_first_stutter (y::tl)
  ;;
  find_first_stutter ["hi";"hola";"ciao";"ciao";"bonjour"];;
#+END_SRC

#+RESULTS:
: - : string option = Some "ciao"

Note that in the code, the pattern | [] | [_] is what’s called an or-pattern, which is a disjunction of two patterns. We use =_= because we don't care what is matched in this case.

We can also define multiple mutually recursive values with the =and= keyword!

#+BEGIN_SRC ocaml
  let rec is_even x =
    if x = 0 then true else is_odd (x - 1)
  and is_odd x =
    if x = 0 then false else is_even (x - 1)
  ;;

  List.map ~f:is_even [0;1;2;3;4;5;6;7];;
#+END_SRC

#+RESULTS:
: Characters 13-20:
:   List.map ~f:is_even [0;1;2;3;4;5;6;7];;;;
:               ^^^^^^^
: Error: The function applied to this argument has type 'a list -> 'b list
: This argument cannot be applied with label ~f

*** COMMENT Prefix and Infix Operators

Look at the following infix call:

=3 + 4=

The =+= in the middle is actually a function call! 

Infix operators like + really only differ syntactically from other functions. In fact, if we put parentheses around an infix operator, you can use it as an ordinary prefix function:

#+BEGIN_SRC ocaml
  (+) 3 4;;    (* int = 7 *)

  List.map ~f:((+) 3) [4;5;6];;
  (* int list = [7; 8; 9; *)
#+END_SRC

*Important thing about infix operators!*

#+BEGIN_QUOTE
A function is treated syntactically as an operator if the name of that function is chosen from one of a specialized set of identifiers. This set includes identifiers that are sequences of characters from the following set:
#+END_QUOTE

=! $ % & * + - . / : < = > ? @ ^ | ~=

=or= is one of a handful of predetermined strings, including mod, the modulus operator

We can define (or redefine) the meaning of an operator (cool!). Here's an example of a simple vector-addition operator on =int= pairs:

#+BEGIN_SRC ocaml :exports both
  let (+!) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2);;

  (3,2) +! (-2,4);;
#+END_SRC

#+RESULTS:
: - : int * int = (1, 6)

*Gotcha!* Be careful with operators containing =*= -- otherwise your operator might be read as a comment! E.g.:

=let (***) x y = (x ** y) ** y;;=

Table 2.1: /Precedence and associativity/

| Operator prefix                        | Associativity     |
|----------------------------------------+-------------------|
| !..., ?..., ~...                       | Prefix            |
| ., .(, .[                              | -                 |
| fn app., constructor, assert, lazy     | Left associative  |
| -, -.                                  | Prefix            |
| **..., lsl, lsr, asr                   | Right associative |
| *..., /..., %..., mod, land, lor, lxor | Left associative  |
| +..., -...                             | Left associative  |
| ::                                     | Right associative |
| @..., ^...                             | Right associative |
| eq..., <..., >..., pipe..., &..., $... | Left associative  |
| &, &&                                  | Right associative |
| or, pipepipe                           | Right associative |
| ,                                      | -                 |
| <-, :=                                 | Right associative |
| if                                     | -                 |
| ;                                      | Right associative |

*Note:* On line 10, =eq= stands for =\== and =pipe= stands for =|=. =pipepipe= on 12 is =||=.

*Note:* There’s one important special case: - and -., which are the integer and floating-point subtraction operators, and can act as both prefix operators (for negation) and infix operators (for subtraction). So, both -x and x - y are meaningful expressions. Another thing to remember about negation is that it has lower precedence than function appli‐ cation, which means that if you want to pass a negative value, you need to wrap it in parentheses:

=Int.max 3 (-4);;=

Here’s an example of a very useful operator from the standard library whose behavior depends critically on the precedence rules described previously:

#+BEGIN_SRC ocaml :exports both
  let (|>) x f = f x;;
#+END_SRC

#+RESULTS:
: val ( |> ) : 'a -> ('a -> 'b) -> 'b = <fun>

(That's compose! I wonder why they don't acknowledge that right now...)

Example:

#+BEGIN_SRC ocaml
  let path = "/usr/bin:/usr/local/bin:/bin:/sbin";;
  String.split ~on:':' path
  |> List.dedup_and_sort ~compare:String.compare
  |> List.iter ~f:print_endline
  ;;

  (*
  /bin
  /sbin
  /usr/bin
  /usr/local/bin
  - : unit = ()
  ,*)
#+END_SRC

/An important part of what’s happening here is partial application/. For example, List.iter normally takes two arguments: a function to be called on each element of the list, and the list to iterate over.

Above, we're partially applying it with =print_endline= because it waits to get its second argument from the composition above it.

But |> only works in the intended way because it is left-associative. Let’s see what happens if we try using a right-associative operator, like =(^>)=:

#+BEGIN_SRC ocaml
  Sys.getenv_exn "PATH"
  ^> String.split ~on:':' path
  ^> List.dedup_and_sort ~compare:String.compare
  ^> List.iter ~f:print_endline
  ;;

  (* Error: This expression has type string list -> unit
   *        but an expression was expected of type
   *          (string list -> string list) -> 'a
   *        Type string list is not compatible with type
   *          string list -> string list  *)
#+END_SRC

What’s going on is that, because =^>= is right associative, the operator is trying to feed the value =List.dedup ~compare:String.compare= to the function =List.iter ~f:print_endline=. But =List.iter ~f:print_endline= expects a list of strings as its input, not a function.

The type error aside, this example highlights the importance of choosing the operator you use with care, particularly with respect to associativity.

*Note:* Review the associativity chart above!!

*** Declaring Functions with Function

You can also declare functions with the =function= keyword.

#+BEGIN_QUOTE
Instead of having syntactic support for declaring multiargument (curried) functions, function has built- in pattern matching.
#+END_QUOTE

Huh?

Example:

#+BEGIN_SRC ocaml
  let some_or_zero = function
    | Some x -> x
    | None -> 0
  ;;

  List.map ~f:some_or_zero [Some 3; None; Some 4];;
  (* : int list = [3; 0; 4] *)
#+END_SRC

This is equivalent to using an ordinary function definition:

#+BEGIN_SRC ocaml
  let some_or_zero num_opt =
    match num_opt with
    | Some x -> x
    | None -> 0;;
#+END_SRC

We can combine the two like this, declaring a 2-argument curried function with a pattern match on the 2nd arg:

#+BEGIN_SRC ocaml
  let some_or_default default = function 
  | Some x -> x
  | None -> default
  ;;

  List.map ~f:(some_or_default 100) [Some 3; None; Some 4];;
  (* - : int list = [3; 100; 4] *)
#+END_SRC

*** Labeled Arguments

We've worked with functions whose parameters are specified /positionally/. OCaml also supports labeled arguments, which let you identify a function arg by name.

Labeled arguments are marked by a leading tilde, and a label (followed by a colon) is put in front of the variable to be labeled.

#+BEGIN_SRC ocaml :exports both
  let ratio ~num ~denom = float num /. float denom;;
#+END_SRC

#+RESULTS:
: val ratio : num:int -> denom:int -> float = <fun>

We can use =ratio= like this:

#+BEGIN_SRC ocaml
  ratio ~num:3 ~denom:10;;
  (* : float = 0.3 *)

  ratio ~denom:10 ~num:3;;
  (* : float = 0.3 *)
#+END_SRC

*Label punning* means you get to drop the text after the =:= if the name of the label & variable being used are the same.

#+BEGIN_SRC ocaml
  let num = 3 in
  let denom = 4 in
  ratio ~num ~denom;;
#+END_SRC

A couple reasons labeled arguments can be useful:

- Choosing label names well is especially important for Boolean values, since it’s often easy to get confused about whether a value being true is meant to enable or disable a given feature.

- When defining functions that have multiple arguments that might get confused with each other. This is most at issue when the arguments are of the same type.

- When you want flexibility on the order in which arguments are passed. Consider a function like List.iter, which takes two arguments: a function and a list of elements to call that function on. A common pattern is to partially apply List.iter by giving it just the function, as in the following example from earlier in the chapter:

  #+BEGIN_SRC ocaml
    String.split ~on:':' path
    |> List.dedup ~compare:String.compare
    |> List.iter ~f:print_endline 
  #+END_SRC

- One common reason is readability. In particular, a multiline function passed as an argument to another function is easiest to read when it is the final argument to that function.

**** Higher-order functions & labels

Consider the following example, where we destructure /and/ use named arguments:

=let apply_to_tuple f (first,second) = f ~first ~second;;=

You can see how this could get very confusing (or simply not work).

*** COMMENT Optional Arguments

Optional arguments are passed in using the same syntax as labeled arguments, and, like labeled arguments, can be provided in any order.

Example:

#+BEGIN_SRC ocaml :exports both
  let concat ?sep x y =
    let sep = match sep with
      | None -> ""
      | Some x -> x in
    x ^ sep ^ y
    ;;
#+END_SRC

#+RESULTS:
: val concat : ?sep:string -> string -> string -> string = <fun>

Let's use it w/ and w/o the optional =sep= argument:

#+BEGIN_SRC ocaml
  concat "foo" "bar";;
  (* : string = "foobar" *)

  concat ~sep:":" "foo" "bar";;
  (* : string = "foo:bar" *)
#+END_SRC

While the caller can pass a value of type string for sep, internally to the function, /sep is seen as a string option/, with None appearing when sep is not provided by the caller.

There is also an explicit syntax for providing a default value:

#+BEGIN_SRC ocaml
  let concat ?(sep="") x y = x ^ sep ^ y;;
#+END_SRC

When to use? /Sparingly/:

#+BEGIN_QUOTE
...rarely used functions should not have optional arguments. A good rule of thumb is to avoid optional arguments for functions internal to a module, i.e., func‐ tions that are not included in the module’s interface, or mli file.
#+END_QUOTE

**** Explicit passing of an optional argument

Note: Reread.
<2018-09-23 Sun>

**** Inference of labeled & optional arguments

Note: Reread.
<2018-09-23 Sun>

#+BEGIN_QUOTE
Since there are multiple plausible types to choose from, OCaml needs some heuristic for choosing between them. The heuristic the compiler uses is to prefer labels to options and to choose the order of arguments that shows up in the source code.
#+END_QUOTE

**** Optional args & partial application

Optional arguments can be tricky to think about in the presence of partial application!


* Chapter 3: Lists & Patterns

[[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter3][Chapter 3 Exercises & Projects Here]]

We can make lists with the =[1;3]= or the =1::3= syntax.

Note that =::= is right associative, which is why we don't need to put parens around multiple successive invocations.

Lists are in fact singly linked lists. This is why =::= can extend a list w/o modifying it.

** Using Patterns to Extract Data from a List

#+BEGIN_QUOTE
[A] match statement in sum is really doing two things: first, it’s acting as a case-analysis tool, breaking down the possibilities into a pattern-indexed list of cases. Second, it lets you name substructures within the data structure being matched.
#+END_QUOTE

Note that we can match for *literal values*.

#+BEGIN_SRC ocaml
  let rec drop_zero list =
    match list with
    | [] -> []
    | 0  :: tl -> drop_zero tl
    | hd :: tl -> hd :: drop_zero tl
  ;;

  drop_zero [1;0;2;3;0];;
  (* [1; 2; 3] *)
#+END_SRC

** Limitations (and Blessings) of Pattern Matching

Patterns can’t be used to express arbitrary conditions. They characterize the layout of a data structure and can even include literals... a pattern can check if a list has two elements, but it can’t check if the first two elements are equal to each other. (?)

#+BEGIN_QUOTE
The fact that the pattern language is limited turns out to be a very good thing, making it possible to build better support for patterns in the compiler. In particular, both the efficiency of match statements and the ability of the compiler to detect errors in matches depend on the constrained nature of patterns.
#+END_QUOTE

*** Performance

*Wildcard:*

=_= is the wildcard pattern and matches any value, but /without binding a variable name to the value in question/.
  
(See chapter3.ml for an example using =core_bench=.

#+BEGIN_QUOTE
In this case, the match-based implementation is many times faster than the if-based implementation. The difference comes because we need to effectively do the same work multiple times, since each function we call has to reexamine the first element of the list to determine whether or not it’s the empty cell. With a match statement, this work happens exactly once per list element.
#+END_QUOTE

Only caveat is long strings:

#+BEGIN_QUOTE
...matches containing a long sequence of strings can be outperformed by a hash table.
#+END_QUOTE


*** Detecting Errors

The error-detecting power of pattern matching might be more important than its performance, because =match= checks statements for exhausiveness.

This makes refactoring much easier, because the compiler will tell you everywhere where stuff is bork!

** Using the List Module Effectively

Using the List module is probably what you'll use most in real life.

Let's look at =map=, =map2_exn= and =fold= by writing a function that renders (or pretty prints) a table.

=map= we're familiar with; =map2_exn= takes 2 lists and a function for combining them, e.g.:

#+BEGIN_SRC ocaml
  List.map2_exn ~f:Int.max [1;2;3] [3;2;1];;
#+END_SRC

The =_exn= is there because the function throws an exception if the lists are of mismatched length.

=fold= is more complicated. It takes 3 arguments: a list, an initial value, and a function for updating the accumulator (it's like reduce!).

Here are 2 uses of =fold=: one which sums a list, another which reverses it.

#+BEGIN_SRC ocaml
  List.fold ~init:0 ~f:(+) [1;2;3;4];;
  (* - : int = 10 *)

  List.fold ~init:[] ~f:(fun list x -> x :: list) [1;2;3;4];;
  (* - : int list = [4; 3; 2; 1] *)
#+END_SRC

Let's put these 3 fns together to compute max column widths:

#+BEGIN_SRC ocaml
  let max_widths header rows =
    let lengths l = List.map ~f:String.length l in
    List.fold rows
      ~init:(lengths header)
      ~f:(fun acc row ->
          List.map2_exn ~f:Int.max acc (lengths row))
  ;;
#+END_SRC

Whoa, I totally get it?

Now that we know how to compute column widths, we can write the code to generate the line that separates the header from the rest of the table.

#+BEGIN_SRC ocaml
  let render_separator widths =
    let pieces = List.map widths
        ~f:(fun w -> String.make (w + 2) '-')
    in
    "|" ^ String.concat ~sep:"+" pieces ^ "|"
  ;;
  (* val render_separator : int list -> string = <fun> *)

  render_separator [12;3;9];;
  (* - : string = "|--------------+-----+-----------|" *)
#+END_SRC

*Note:* Performance of =String.concat= and =^=

- Avoid =^= for joining long numbres of strings b/c it allocates a new string every time it runs.

- Sounds like O(n^2) run time

Now let's render a row w/ data in it. We'll write a fn called =pad=:

#+BEGIN_SRC ocaml
  let pad s length =
    " " ^ s ^ String.make (length - String.length s + 1) ' '
  ;;
  (* val pad : string -> int -> string = <fun> *)

  pad "hello" 10;;
  (* - : string = " hello      " *)
#+END_SRC

We'll use =map2_exn= to combine the list of data in the row w/ the list of widths:

#+BEGIN_SRC ocaml
  let render_row row widths =
    let padded = List.map2_exn row widths ~f:pad in
    "|" ^ String.concat ~sep:"|" padded ^ "|"
  ;;
  (* val render_row : string list -> int list -> string = <fun> *)

  render_row ["Hello";"World"] [12; 9];;
  (* - : string = "| Hello        | World     |" *)
#+END_SRC

Now let's bring it all together:

#+BEGIN_SRC ocaml
  let render_table header rows =
    let widths = max_widths header rows in
    String.concat ~sep:"\n"
      (render_row header widths
       :: render_separator widths
       :: List.map rows ~f:(fun row -> render_row row widths)
      )
  ;;
  (* val render_table : string list -> string list list -> string = <fun> *)

  printf "%s\n"
    (render_table
       ["language";"architect";"first release"]
       [ ["Lisp" ;"John McCarthy" ;"1958"] ;
         ["C"    ;"Dennis Ritchie";"1969"] ;
         ["ML"   ;"Robin Milner"  ;"1973"] ;
         ["OCaml";"Xavier Leroy"  ;"1996"] ;
  ]);;

  (* | language | architect      | first release |
   ,* |----------+----------------+---------------|
   ,* | Lisp     | John McCarthy  | 1958          |
   ,* | C        | Dennis Ritchie | 1969          |
   ,* | ML       | Robin Milner   | 1973          |
   ,* | OCaml    | Xavier Leroy   | 1996          |
   ,* - : unit = () *)
#+END_SRC

That was super fun. And look, it makes an org table:

| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |

*** More Useful List Functions

**** Combining list elements with =List.reduce=

=List.fold= is very powerful. Sometimes though you want something easier to use. =reduce= is a specialized version of =fold= that doesn't require an explicit starting value.

Also the acc has to consume and product values of the same type as the elements of the list it allies to.

Type signature:

#+BEGIN_SRC ocaml
  List.reduce;;
  (* - : 'a list -> f:('a -> 'a -> 'a) -> 'a option = <fun> *)
#+END_SRC

=reduce= returns an /optional/ result, returning None when the list is empty.

Examples:

#+BEGIN_SRC ocaml
  List.reduce ~f:(+) [2;3;4;5;6;7];;
  (* - : int option = Some 27 *)
  List.reduce ~f:(+) [];;
  (* - : int option = None *)
#+END_SRC

**** Filtering with =List.filter= and =List.filter_map=

#+BEGIN_SRC ocaml
  List.filter ~f:(fun x -> x mod 2 = 0) [20;21;22;23;24;25];;
  (* - : int list = [2; 4] *)
#+END_SRC

Sometimes you want to transform /and/ filter in the same computation.

The function passed to =List.filter_map= returns an /optional value/, and =List.filter_map= drops all elements that return None.

Let's write a function that reads the unique file extensions in the current directory:

[[http://dev.realworldocaml.org/lists-and-patterns.html#filtering-with-list.filter-and-list.filter_map][Corrected version of this function available here]].

#+BEGIN_SRC ocaml
  List.filter_map;;
  (* - : 'a list -> f:('a -> 'b option) -> 'b list = <fun> *)

  let extensions filenames =
    List.filter_map filenames ~f:(fun fname ->
        match String.rsplit2 ~on:'.' fname with
        | None | Some ("",_) -> None
        | Some (_,ext) ->
          Some ext)
    |> List.dedup_and_sort ~compare:String.compare
  ;;
  (* val extensions : string list -> string list = <fun> *)

  extensions (Sys.ls_dir ".");;
  (* - : string list = ["ml"; "native"; "org"] *)
#+END_SRC

**** Partitioning with =List.partition_tf=

Closely related to filtering is partitioning. =partition_tf= takes a list and a function for computing a Boolean condition on the list elements, and returns 2 lists. 

The =tf= in the name is a mnemonic to remind the user that =true= elements go in the 1st list, =false= in the 2nd.

#+BEGIN_SRC ocaml
  let is_ocaml_source s =
    match String.rsplit2 s ~on:'.' with
    | Some (_,("ml"|"mli")) -> true
    | _ -> false
  ;;

  let (ml_files,other_files) =
    List.partition_tf (Sys.ls_dir ".") ~f:is_ocaml_source;;
  (* val ml_files : string list =
   ,*                ["chapter1.ml"; "sum.ml"; "chapter3.ml"; "chapter2.ml"] *)
  (* val other_files : string list = ["_build"; "readme.org"; "sum.native"] *)
#+END_SRC

**** Combining lists

Concatenation comes up a lot. There are a couple ways of doing it.

1. First there's =List.append=, /for concatenating 2 lists/:
   (Note that we can also use the =@= operator)

   #+BEGIN_SRC ocaml
     List.append [1;2;3] [4;5;6];;
     (* - : int list = [1;2;3;4;5;6] *)
   #+END_SRC

2. Second is =List.concat=, /for concatenating a list of lists/:

   #+BEGIN_SRC ocaml
     List.concat [[1;2];[3;4];[5;6];[7];[]];;
     (* - : int list = [1; 2; 3; 4; 5; 6; 7] *)
   #+END_SRC
   
   Example of using =List.concat= with =List.map= to compute a recursive listing of a directory tree:

   #+BEGIN_SRC ocaml
     let rec ls_rec s =
       if Sys.is_file_exn ~follow_symlinks:true s
       then [s]
       else
         Sys.ls_dir s
         |> List.map ~f:(fun sub -> ls_rec (s ^/ sub))
         |> List.concat
     ;;
   #+END_SRC

   Note that ^/ is an infix operator provided by Core for adding a new element to a string representing a file path. It is equivalent to Core’s Filename.concat

   Or, we could just use =List.concat_map=, which makes only 1 pass over our data:

   #+BEGIN_SRC ocaml
     let rec ls_rec s =
       if Sys.is_file_exn ~follow_symlinks:true s
       then [s]
       else
         Sys.ls_dir s
         |> List.concat_map ~f:(fun sub -> ls_rec (s ^/ sub))
     ;;

     ls_rec ".";;
     (* - : string list =
      ,* ["./chapter1.ml"; "./sum.ml"; "./_build/sum.ml.depends"; "./_build/_digests"; "./_build/sum.cmt"; "./_build/sum.cmo"; "./_build/sum.cmi"; "./_build/_log"; "./_build/sum.ml"; "./_build/ocamlc.where"; "./_build/sum.o"; "./_build/sum.cmx"; "./_build/sum.native"; "./readme.org"; "./sum.native"; "./chapter3.ml"; "./chapter2.ml"] *)
   #+END_SRC

*** COMMENT Tail Recursion

Non-tail recursive:

#+BEGIN_SRC ocaml
  let rec length = function
    | [] -> 0
    | _ :: tl -> 1 + length tl
  ;;
#+END_SRC

Tail recursive:

#+BEGIN_SRC ocaml
  let rec length_plus_n l n =
    match l with
    | [] -> n
    | _ :: tl -> length_plus_n tl (n + 1)
  ;;

  let length l = length_plus_n l 0;;
#+END_SRC

The invocation is considered a tail call when the caller doesn’t do anything with the value returned by the callee except to return it.

#+BEGIN_QUOTE
Ordinary nontail recursive calls are reasonable when dealing with data structures like binary trees, where the depth of the tree is logarithmic in the size of your data. But when dealing with situations where the depth of the sequence of nested calls is on the order of the size of your data, tail recursion is usually the right approach.
#+END_QUOTE

*** Terser and Faster Patterns

Let's improve our =destutter= function. Our previous implementation:

#+BEGIN_SRC ocaml
  let rec destutter list =
    match list with
    | [] -> []
    | [hd] -> [hd]
    | hd :: hd' :: tl ->
      if hd = hd' then destutter (hd' :: tl)
      else hd :: destutter (hd' :: tl)
  ;;
#+END_SRC

Is it efficient? Sometimes it recreates on the right side of the arrow a value that already existed on the left. Thus, =[hd] -> [hd]= allocates a new element.

/Introducing =as=!/

We can reduce here by using an *as pattern*, which allows us sto declare a name for the thing matched by a pattern by using the keyword =as=.

We can also use =function= while we're at it to eliminate the need for an explicit match /(??)/.

#+BEGIN_SRC ocaml
  let rec destutter = function
    | [] as l -> l
    | [_] as l -> l
    | hd :: (hd' :: _ as tl) ->
      if hd = hd' then destutter tl
      else hd :: destutter tl
  ;;
#+END_SRC

Let's go one step further and combine the 1st 2 cases into one using an Or pattern:

#+BEGIN_SRC ocaml
  let rec destutter = function
    | [] | [_] as l -> l
    | hd :: (hd' :: _ as tl) ->
      if hd = hd' then destutter tl
      else hd :: destutter tl
  ;;
#+END_SRC

Can we go further?

/Introducing =when=!/

A =when= clause allows us to add an extra precondition to a pattern. Here we check whether the first 2 elements are equal:

#+BEGIN_SRC ocaml
  let rec destutter = function
    | [] | [_] as l -> l
    | hd :: (hd' :: _ as tl) when hd = hd' -> destutter tl
    | hd :: tl -> hd :: destutter tl
  ;;
#+END_SRC

Note that =when= clauses have some downsides. Once we add the ability to add an arbitrary condition to a pattern, something will be lost: the compiler's ability to determine if a match is exhausted.

Consider this function:

#+BEGIN_SRC ocaml
  let rec count_some list =
    match list with
    | [] -> 0
    | x :: tl when Option.is_none x -> count_some tl
    | x :: tl when Option.is_some x -> 1 + count_some tl
  ;;

  (* Warning 8: this pattern-matching is not exhaustive.
   ,*     Here is an example of a value that is not matched:
   ,*     _::_
   ,*     (However, some guarded clause may match this value.)
   ,*     val count_some : 'a option list -> int = <fun> *)
#+END_SRC

The function does actually work fine. If we added another redundant case w/o a =when= clause, the compiler will stop complaining.

A better approach would probably be to drop the second when clause and do:

=| _ :: tl -> 1 + count_some tl=

But the best solution is probably to drop the =when= clause and just match on =None= and =Some=:

#+BEGIN_SRC ocaml
  let rec count_some list =
    match list with
    | [] -> 0
    | None   :: tl -> count_some tl
    | Some _ :: tl -> 1 + count_some tl
  ;;
#+END_SRC

The takeaway from all of this is although when clauses can be useful, we should prefer patterns wherever they are sufficient.

Finally, this is how you would probably implement =count_some= in real life; this version is tail recursive, and uses =List.count=:

#+BEGIN_SRC ocaml
  let count_some l = List.count ~f:Option.is_some l;;
#+END_SRC

*** Polymorphic Compare

In our last implementation of =destutter= we made use of the fact that OCaml lets us test equality between values of any type, using the = operator.

This works on lists, too!

=[3;4;5] = [3;4;5]=
=[Some 3; None] = [Some 3; None];;=

Let's inspect the equality operator:

#+BEGIN_SRC ocaml :exports both
  (=);;
#+END_SRC

#+RESULTS:
: - : 'a -> 'a -> bool = <fun>

We can indeed see that it is polymorphic.

Polymorphic compare does have some limitations. For example, it will fail at runtime if it encounters a function value:

#+BEGIN_SRC ocaml :exports both
  (fun x -> x + 1) = (fun x -> x + 1);;
#+END_SRC

#+RESULTS:
: Exception: Invalid_argument "compare: functional value".

*Note:* For strings comparison operators use a lexicographic comparison.


* Chapter 4: Files, Modules & Programs

[[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter4][Chapter 4 Exercises & Projects Here]]

** Single File Programs

We’ll start with an example: a utility that reads lines from stdin and computes a fre‐ quency count of the lines.

We'll use 2 fns from the =List.assoc= library, utility functions for interacting with association lists, i.e., lists of key/value pairs.

1. =List.Assoc.find= looks up a key in an association list

   #+BEGIN_SRC ocaml
     let assoc = [("one", 1); ("two",2); ("three",3)];; 
     List.Assoc.find assoc "two";;
     (* - : int option = Some 2 *)
   #+END_SRC

2. =List.Assoc.add= adds a new binding to an association list

   #+BEGIN_SRC ocaml
     List.Assoc.add assoc "four" 4;; (* add a new key *)
     (* - : (string, int) List.Assoc.t = [("four", 4); ("one", 1); ("two", 2); ("three", 3)] *)
     List.Assoc.add assoc "two" 4;;  (* updates existing key *)
     (* - : (string, int) List.Assoc.t = [("two", 4); ("one", 1); ("three", 3)] *)
   #+END_SRC
   
To read the program, see [[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter4/freq.ml][freq.ml]] located in this directory.

Unlike C, programs in OCaml do not have a unique main function. When an OCaml program is evaluated, all the statements in the im‐ plementation files are evaluated in the order in which they were linked together.

With just vanilla OCaml, we could build the executable like so:

#+BEGIN_SRC shell
  $ ocamlc freq.ml -o freq.byte
#+END_SRC

But we get an unbound module because we're using Core. To get Core in, we do:

#+BEGIN_SRC shell
  $ ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq.byte
#+END_SRC

Explanation:

#+BEGIN_QUOTE
This uses ocamlfind, a tool which itself invokes other parts of the OCaml toolchain (in this case, ocamlc) with the appropriate flags to link in particular libraries and packages. Here, -package core is asking ocamlfind to link in the Core library; -linkpkg asks ocamlfind to link in the packages as is necessary for building an executable, while -thread turns on threading support (which is required for Base).
#+END_QUOTE

Buuut we're not gonna mess with that because we have /jbuilder/. Create a =jbuild= file:

#+BEGIN_SRC lisp
  (executable
   ((name freq)
    (libraries (base stdio))))
#+END_SRC

Then we can invoke jbuilder:

#+BEGIN_SRC shell
  jbuilder build freq.bc
#+END_SRC

If we’d invoked corebuild with a target of freq.native instead of freq.byte, we would have gotten native code instead.

Here's how we invoke it, extracting strings from the /ocamlopt/ binary:

#+BEGIN_SRC shell
  $ strings `which ocamlopt` | ./_build/default/freq.bc
#+END_SRC

Which produces the top 10 most frequently repeated strings & their count:

#+BEGIN_SRC shell
   90: <hov2>
   78: list.ml
   54: bytecomp/matching.ml
   53: p``;
   46: <hov>
   45: typing/env.ml
   45: typing/parmatch.ml
   44: string.ml
   42: utils/misc.ml
   41: typing/ctype.ml
#+END_SRC

*** Bytecode Versus Native Code

OCaml ships with 2 compilers: /ocamlc/ for bytecode and /ocamlopt/ for native-code.

- =ocamlc=
  - Programs compiled with /ocamlc/ are interpreted by a virtual machine
  - /jbuilder/ builds =.byte= files as bytecode executables
- =ocamlopt=
  - Programs compiled with /ocamlopt/ are compiled to native machine code to be run on a specific operating system & processor architecture
  - /jbuilder/ builds =.native= files as native code
    
Besides performance, these executables behave nearly identically. Some things to be aware of:

1. The bytecode compiler can be used on more architectures & have tools not available for native code (e.g., the OCaml debugger)
2. The bytecode compiler is quicker than the native compiler
3. To run a bytecode executable, you (usually) need OCaml installed on the system
4. Generally production executables should be built using the native-code compiler, but bytecode makes sense for dev builds

** Multifile Programs & Modules

Source files compile down into a module whose name is derived from the name of the file.

At its simplest, we can think of a module as a collection of definitions store w/in a namespace.

Let's refactor =freq.ml=. Updating an assoc. list takes linear time based on the list's length, which means processing a file has a quadratic time complexity.

First we'll factor out some functionality into a module w/ an explicit interface.

We'll create [[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter4/counter.ml][counter.ml]], which will be compiled into a module named =Counter=. Module names are always capitalized.

jbuild will compile =counter.ml= automatically when it finds =Counter= in freq and realizes that it needs a dependency.

:sparkle:

** Signatures and Abstract Types

The implementation details of a module can be hidden by attaching an /interface/.

Note that w/ OCaml, /interfact/, /signature/ and /module type/ are interchangeable. A module =filename.ml= can be constrained by a signature place in a file called =filename.mli=.

