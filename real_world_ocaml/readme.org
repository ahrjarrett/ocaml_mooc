#+TITLE: Real World OCaml Notes
#+AUTHOR: Andrew Jarrett
#+DATE: <2018-09-22 Sat>


* Getting Everything Set up & Installed

The instructions in the book are dated, so I used [[https://dev.realworldocaml.org/install.html][this tutorial]] to get OCaml, the package manager, and a number of libraries set up and installed for working through the book.

** Core

When trying to evaluate =open Core.Std;;= in utop (like the book recommends), you'll crash headfirst into =Unbound module Core=.

Make sure you've installed core.

=$ opam install Core=

Then in utop you can do:

=# #require "Core";;=

Note that the second =#= is not part of the prompt, but part of what you type in. Afterwards you can do:

=# open Core;;=

And you're good to start using Core.

** Other libraries:

While we're at it, let's just install everything we'll need for the book:

=$ opam install async yojson core_extended core_bench cohttp async_graphics cryptokit menhir=

Installs:

- opam 
- install 
- async 
- yojson 
- core_extended 
- core_bench 
- cohttp 
- async_graphics 
- cryptokit 
- menhir





* Chapter 1: A Guided Tour

[[https://github.com/ahrjarrett/ocaml_mooc/blob/master/real_world_ocaml/chapter1.ml][Chapter 1 Exercises & Practice Here]]

p.3

#+BEGIN_QUOTE
Throughout the book we’re going to use Core, a more full-featured and capable re‐ placement for OCaml’s standard library. 
#+END_QUOTE

** OCaml as a Calculator

Using Core:

#+BEGIN_SRC ocaml
  $ utop
  # open Core;; (* book says `open Core.std;;`, but this looks to be defunct *)
#+END_SRC

A note on =;;=:

#+BEGIN_QUOTE
We needed to type ;; in order to tell the toplevel that it should evaluate an expres‐ sion. This is a peculiarity of the toplevel that is not required in standalone programs (though it is sometimes helpful to include ;; to improve OCaml’s error reporting, by making it more explicit where a given top-level declaration was intended to end).
#+END_QUOTE

A note on underscores in numbers:

#+BEGIN_QUOTE
OCaml allows you to place underscores in the middle of numeric literals to improve readability.
#+END_QUOTE

Example:

=30_000_000 / 300_000=

On syntax for /let bindings/:

#+BEGIN_QUOTE
Punctuation is excluded, except for _ and ', and variables must start with a lowercase letter or an underscore
#+END_QUOTE

** Functions & Type Inference

The let syntax can also be used to define a function.

Looking at types, briefly:

#+BEGIN_SRC ocaml
  # let ratio x  y=
  Float.of_int x /. Float.of_int y
  ;;
  val ratio : int -> int -> float = <fun> # ratio 4 7;;
  - : float = 0.571428571429
#+END_SRC

Here we use the Float module. Note that module names always start with a capital letter.

Because functions are first-class in OCaml, we can pass functions as arguments:

#+BEGIN_SRC ocaml :exports both
  let sum_if_true test first second =
    (if test first then first else 0)
    + (if test second then second else 0)
  ;;  (* val sum_if_true : (int -> bool) -> int -> int -> int = <fun> *)

  let even x =
    x mod 2 = 0;;

  sum_if_true even 8 4;;          (* 12 *)

  sum_if_true even 3 2;;          (* 2 *)
#+END_SRC

#+RESULTS:
: 2

Look how it inferred the type of our =test= function! So cool.

** Type inference

How did it infer that =sum_if_true= took a function of type (int -> bool)?

OCaml requires that both branches of an if statement have the same type:

#+BEGIN_QUOTE
OCaml requires that both branches of an if statement have the same type, so the expression if test first then first else 0 requires that first must be the same type as 0, and so first must be of type int.
#+END_QUOTE

To help with getting an intuition for this, let's annotate sum_if_true:

#+BEGIN_SRC ocaml :exports both
let sum_if_true (test : int -> bool) (x : int) (y : int) : int =
  (if test x then x else 0)
  + (if test y then y else 0) ;;
#+END_SRC

#+RESULTS:
: val sum_if_true : (int -> bool) -> int -> int -> int = <fun>

** Inferring Generic Types

Sometimes there isn't enough info to infer a variable's type, for example:

#+BEGIN_SRC ocaml :exports both
let first_if_true test x y =
  if test x then x else y;;
#+END_SRC

#+RESULTS:
: val first_if_true : ('a -> bool) -> 'a -> 'a -> 'a = <fun>

OCaml has introduced a *type variable* \'a to express that the type is generic. This kind of genericity is called *parametric polymorphism*.

#+BEGIN_QUOTE
Whatever type 'a is, it has to be the same as the type of the other two arguments, x and y, and of the return value of firstiftrue. This kind of genericity is called parametric polymorphism because it works by parameterizing the type in question with a type variable
#+END_QUOTE

#+BEGIN_SRC ocaml :exports both
let first_if_true test x y =
  if test x then x else y;;

let long_string s = String.length s > 6;;

first_if_true long_string "short" "lonnnnnng";;
#+END_SRC

#+RESULTS:
: lonnnnnng

We can use =first_if_true= with ints, too:

#+BEGIN_SRC ocaml :exports both
let big_number x = x > 3;;

first_if_true big_number 4 3;;
#+END_SRC

#+RESULTS:
: 4

** Type Errors Versus Exceptions

Big difference is that (usually) type errors are encountered at compile time, and exceptions occur at run time.

Exceptions occur for things the compiler can't check, for example division by zero.

#+BEGIN_SRC ocaml :exports both
let is_a_multiple x y = x mod y = 0 ;;
val is_a_multiple : int -> int -> bool = <fun> # is_a_multiple 8 2;;
is_a_multiple 8 0;;
#+END_SRC

#+RESULTS:
: Exception: Division_by_zero.

** Tupes, Lists, Options & Pattern Matching

*** Tuples

You can create a tuple by joining values together with a comma:

#+BEGIN_SRC ocaml :exports both
let a_tuple = (3,"three");;
#+END_SRC

#+RESULTS:
: val a_tuple : int * string = (3, "three")

What's going on with the asterisk?

#+BEGIN_QUOTE
(For the mathematically inclined, the * character is used because the set of all pairs of type t * s corresponds to the Cartesian product of the set of elements of type t and the set of elements of type s.)
#+END_QUOTE

You can extract the components of a tuple using OCaml’s pattern-matching syntax:

=let (x,y) = a_tuple;;=

/Note that the same syntax is used both for constructing and for pattern matching on tuples./

We can also take advantage of pattern matching in function arguments:

#+BEGIN_SRC ocaml :exports both
  let distance (x1,y1) (x2,y2) =
    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) **2.)
#+END_SRC

#+RESULTS:
: val distance : float * float -> float * float -> float = <fun>

The =**= operator used above is for raising a floating-point number to a power.

*** Lists

Lists let you hold any number of items of the same type

#+BEGIN_SRC ocaml :exports both
  let languages = ["OCaml"; "Clojure"; "JavaScript"]

  let numbers = [3; "four"; 5]
#+END_SRC

**** The List module

Core comes with a =List= module:

#+BEGIN_SRC ocaml
  Open Core;;

  List.length languages;;                 (* int = 3 *)

  List.map languages ~f:String.length;;   (* int list = [4; 7; 10] *)
#+END_SRC

=List.map= takes a list and a function. Notice how we use a *labelled argument*, in this case =~f=. /Labelled arguments are specified by name/, rather than by position.

So we could also have done:

=List.map ~f:String.length languages=

**** Constructing lists with =::=

We can use the =::= operator for adding elements to the front of a list.

#+BEGIN_SRC ocaml
  "French" :: "Cantonese" :: languages
  (* : string list = ["French"; "Spanish"; "OCaml"; "Clojure"; "JavaScript"] *)
#+END_SRC

*Note:* We separate values in a list with /semicolons/ instead of commas. Commas are for separating elements in a tuple.

If we forget and use commas, we get something different that we expect:

#+BEGIN_SRC ocaml :exports both
  ["OCaml", "Perl", "C"];;
#+END_SRC

#+RESULTS:
: - : (string * string * string) list = [("OCaml", "Perl", "C")]

It's a list of tuples of type =(string * string * string)=.

This is because /commas create a tuple even if there are no surrounding parens/.

The bracket notation is just syntactic sugar for =::=.

=::= only adds 1 element to the list. What about list concatenation?

There’s a list concatenation operator, =@=, which can concatenate two lists:

#+BEGIN_SRC ocaml :exports both
  [1;2;3]@[4;5;6]

#+END_SRC

#+RESULTS:
: - : int list = [1; 2; 3; 4; 5; 6]

*List concat time complexity*: =@= is not constant-time. Concatting two lists takes time /proportional to the length of the first list/.

**** List patterns using match

We can use pattern matching to access elements of a list.

#+BEGIN_SRC ocaml :exports both
  let my_fav_lang (my_fav :: the_rest) =
    my_fav
#+END_SRC

#+RESULTS:
: Characters 16-47:
:   ................(my_fav :: the_rest) =
:     my_fav..
: Warning 8: this pattern-matching is not exhaustive.
: Here is an example of a case that is not matched:
: []
: val my_fav_lang : 'a list -> 'a = <fun>

Notice that we get a warning that our matching is not exhaustive! Let's take care of that by using a =match= statement.

#+BEGIN_QUOTE
(Pattern matching) essentially lets you list a sequence of patterns, separated by pipe characters (|). (The one before the first case is optional.)
#+END_QUOTE

#+BEGIN_SRC ocaml :exports true
  let languages = ["French"; "Spanish"; "OCaml"; "Clojure"; "JavaScript"]

  let my_fav_lang languages =
    match languages with
    | first :: the_rest -> first
    | [] -> "OCaml";;
#+END_SRC

#+RESULTS:
: val languages : string list =
:   ["French"; "Spanish"; "OCaml"; "Clojure"; "JavaScript"]
: val my_fav_lang : string list -> string = <fun>

#+BEGIN_SRC ocaml :exports true
my_fav_lang languages;;
#+END_SRC

#+RESULTS:
: French

#+BEGIN_SRC ocaml :exports both
my_fav_lang [];;
#+END_SRC

#+RESULTS:
: OCaml

**** Recursive list functions

Use the =rec= keyword after let to tell the compiler that this is a recursive function.

#+BEGIN_QUOTE
The typical approach to designing a recursive function is to separate the logic into a set of base cases that can be solved directly and a set of inductive cases, where the function breaks the problem down into smaller pieces and then calls itself to solve those smaller problems.
#+END_QUOTE

When writing recursive list functions, this separation between the base cases and the inductive cases is often done using pattern matching.

#+BEGIN_SRC ocaml :exports both
  let rec sum l =
    match l with
    | [] -> 0
    | hd::tl -> hd + sum tl;;

  sum [1;2;3;4;5];;
#+END_SRC

#+RESULTS:
: 15

Here's a function for removing sequential duplicates:

#+BEGIN_SRC ocaml :exports both
  let rec destutter list =
    match list with
    | [] -> []
    | hd1 :: hd2 :: tl ->
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl);;
#+END_SRC

#+RESULTS:
#+begin_example
Characters 27-161:
  ..match list with
    | [] -> []
    | hd1 :: hd2 :: tl ->
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)....
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::[]
val destutter : 'a list -> 'a list = <fun>
#+end_example

Why are we getting this warning message? Because we're not handling the 1-element list case.

#+BEGIN_SRC ocaml :exports both
  let rec destutter list =
    match list with
    | [] -> []
    | [hd] -> [hd]  (* This is different than SML, I think... *)
    | hd1 :: hd2 :: tl ->
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl);;
#+END_SRC

#+RESULTS:
: val destutter : 'a list -> 'a list = <fun>

Let's use it:

#+BEGIN_SRC ocaml :exports both
destutter ["yo";"yo";"ma"];;
#+END_SRC

#+RESULTS:
: - : string list = ["yo"; "ma"]

Note that this code used another variant of the list pattern, [hd], to match a list with a single element. We can do this to match a list with any fixed number of elements; for example, [x;y;z] will match any list with exactly three elements and will bind those elements to the variables x, y, and z.

**** Options

*** Options

An option is used to express that a value might or might not be present.

#+BEGIN_SRC ocaml 
  let divide x y =
    if y = 0 then None else Some(x/y);;
  (* val divide : int -> int -> int option = <fun> *)

  let log_entry maybe_time message =
    let time =
      match maybe_time with
      | Some x -> x
      | None -> Time.now()
    in
    Time.to_sec_string time ^ " -- " ^ message;;
  (* val log_entry : Time.t option -> string -> string = <fun> *)

  log_entry (Some Time.epoch) "A long long time ago";;
  (* string = "1970-01-01 01:00:00 -- A long long time ago" *)

  log_entry None "Up to the minute";;
  (* string = "2013-08-18 14:48:08 -- Up to the minute" *)
#+END_SRC


This example uses Core’s Time module for dealing with time, as well as the ^ operator for concatenating strings. /The concatenation operator is provided as part of the Pervasives module/, which is automatically opened in every OCaml program.

#+BEGIN_QUOTE
Options are important because they are the standard way in OCaml to encode a value that might not be there; there’s no such thing as a =NullPointerException= in OCaml
#+END_QUOTE

A value of type =string * string= always contains two well-defined values of type string. If you want to allow, say, the first of those to be absent, then you need to change the type to =string option * string=.

*** Records & Variants

We can also define our own data types. For example:

#+BEGIN_SRC ocaml :exports both
  type point2d = { x : float; y : float };;
#+END_SRC

#+RESULTS:
: type point2d = { x : float; y : float; }

=point2d= is a *record* type, which is like a tuple where the fields are named instead of being defined positionally.

We can get the contents of a record using pattern matching:

#+BEGIN_SRC ocaml :exports both
  let magnitude { x = x_pos; y = y_pos } =
    sqrt (x_pos ** 2. +. y_pos ** 2.);;
#+END_SRC

#+RESULTS:
: val magnitude : point2d -> float = <fun>

Look at that! The interpreter figured out that the argument to magnitude is point2d, our custom type!

We can write this more tersely using *field punning*. We could simply have done:

=let magnitude { x; y } = ...=

We can also use dot notation for accessing record fields:

#+BEGIN_SRC ocaml :exports both
  let distance v1 v2 =
    magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };;
#+END_SRC

#+RESULTS:
: val distance : point2d -> point2d -> float = <fun>

Let's make some more custom types:

#+BEGIN_SRC ocaml :exports both
  type circle_desc = { center: point2d; radius: float }
  type rect_desc   = { lower_left: point2d; width: float; height: float }
  type segment_desc = { endpoint1: point2d; endpoint2: point2d };;
#+END_SRC

#+RESULTS:
: type circle_desc = { center : point2d; radius : float; }
: type rect_desc = { lower_left : point2d; width : float; height : float; }
: type segment_desc = { endpoint1 : point2d; endpoint2 : point2d; }

Now let's combine some of these together into a *variant type*:

#+BEGIN_SRC ocaml :exports both
  type scene_element =
    | Circle  of circle_desc
    | Rect    of rect_desc
    | Segment of segment_desc
  ;;
#+END_SRC

#+RESULTS:
: type scene_element =
:     Circle of circle_desc
:   | Rect of rect_desc
:   | Segment of segment_desc

The pipe character separates the different cases of the variant. Note that /each case has a capitalized tab/.

#+BEGIN_SRC ocaml :exports both
  let is_inside_scene_element point scene_element =
    match scene_element with
    | Circle { center; radius } ->
      distance center point < radius
    | Rect { lower_left; width; height } ->
      point.x    > lower_left.x && point.x < lower_left.x +. width
      && point.y > lower_left.y && point.y < lower_left.y +. height
    | Segment { endpoint1; endpoint2 } -> false
  ;;
#+END_SRC

#+RESULTS:
: val is_inside_scene_element : point2d -> scene_element -> bool = <fun>

Now let's test our cool function:

#+BEGIN_SRC ocaml
  let is_inside_scene point scene =
    List.exists scene
      ~f:(fun el -> is_inside_scene_element point el)
  ;;
  (* val is_inside_scene : point2d -> scene_element list -> bool = <fun> *)

  is_inside_scene {x=3.;y=7.}
    [ Circle {center = {x=4.;y= 4.}; radius = 0.5 } ];;
  (* : bool = false *)

  is_inside_scene {x=3.;y=7.}
    [ Circle {center = {x=4.;y= 4.}; radius = 5.0 } ];;
  (* : bool = true *)
#+END_SRC

[[https://stackoverflow.com/questions/4513910/how-to-access-a-list-in-ocaml][List.exists discussed on Stack Overflow]]. It seems to be part of the Core library.

The exists function will return true if any element in the list satisfies the predicate (the function). Reminds me of the =Array.prototype.some= function in JS.

We also made our first use of an anonymous function in the call to List.exists using the =fun= keyword and the =->= arrow after the arguments.

** Imperative Programming

OCaml has data structures that are mutable, too.

*** Arrays

Indexes start at 0; accessing or modifying an array element happens in /contant time/.

#+BEGIN_SRC ocaml :exports both
  let numbers=[| 1;2;3;4 |];;
#+END_SRC

#+RESULTS:
: val numbers : int array = [|1; 2; 3; 4|]

Now we can mutate the array:

#+BEGIN_SRC ocaml :exports both
  numbers.(2) <- 4;;
  (* : unit = () *)

  numbers;;
#+END_SRC

#+RESULTS:
: - : int array = [|1; 2; 4; 4|]

The =.(i)= syntax is used to refer to an element of the array, and the =<-= syntax is for modification/mutation.

On =unit=:

#+BEGIN_QUOTE
The unit type that we see in the preceding code is interesting in that it has only one possible value, written (). This means that a value of type unit doesn’t convey any information, and so is generally used as a placeholder. Thus, we use unit for the return value of an operation like setting a mutable field that communicates by side effect rather than by returning a value.
#+END_QUOTE

*** Mutable Record Fields

Records are immutable by default, but some of their fields can be explicitly declared to be mutable.

#+BEGIN_SRC ocaml :exports both
  type running_sum =
    { mutable sum: float;
      mutable sum_sq: float;      (* sum of squares *)
      mutable samples: int;
    }
  ;;

  let mean rsum = rsum.sum /. float rsum.samples let stdev rsum =
       sqrt (rsum.sum_sq /. float rsum.samples
             -. (rsum.sum /. float rsum.samples) ** 2.) ;;
#+END_SRC

#+RESULTS:
: val mean : running_sum -> float = <fun>
: val stdev : running_sum -> float = <fun>

Notice the function =float=, which is a convenient equivalent to =Float.of_int= and is provided by the =Pervasives= library.

We need functions to create an update =running_sums=:

#+BEGIN_SRC ocaml :exports both
  let create () = { sum=0.; sum_sq=0.; samples=0 }
  let update rsum x =
    rsum.samples <- rsum.samples + 1;
    rsum.sum     <- rsum.sum     +. x;
    rsum.sum_sq  <- rsum.sum_sq  +. x *. x
  ;;
#+END_SRC

#+RESULTS:
: val create : unit -> running_sum = <fun>
: val update : running_sum -> float -> unit = <fun>

Note the use of single semicolons to sequence operations. When we were working purely functionally, this wasn’t necessary, but you start needing it when you’re writing imperative code.

Let's mutate!

#+BEGIN_SRC ocaml
  let rsum = create ();;
  (* val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0} *)

  List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -> update rsum x);;
  (* unit = () *)

  mean rsum;;
  (* float = 1.33333333333 *)

  stdev rsum;;
  (* float = 3.94405318873 *)
#+END_SRC

*** Refs

We create a single mutable value by using a =ref=. A =ref= is a record type with a single mutable field called =contents=:

#+BEGIN_SRC ocaml :exports both
  let x = { contents = 0 };;
  (* val x : int ref = {contents = 0} *)

  x.contents <- x.contents + 1;;
  (* unit = () *)

  x;;
#+END_SRC

#+RESULTS:
: - : int ref = {contents = 1}

There are some useful functions and operators to make =refs= more convenient to work with:

=let x = ref 0= means create a ref with contents = 0
=!x= means get the contents of a ref, i.e. x.contents
=x \:\\=\ !x+1 means assignment, i.e. x.contents <- ...

The =ref= type is simple; we can completely reimplement it:

#+BEGIN_SRC ocaml :exports both
  type 'a ref = { mutable contents : 'a }

  let ref x = { contents = x }
  let (!) r = r.contents
  let (:=) r x = r.contents <- x
  ;;
#+END_SRC

#+RESULTS:
: type 'a ref = { mutable contents : 'a; }
: val ref : 'a -> 'a ref = <fun>
: val ( ! ) : 'a ref -> 'a = <fun>
: val ( := ) : 'a ref -> 'a -> unit = <fun>

The 'a before the ref indicates that the ref type is polymorphic, in the same way that lists are polymorphic, meaning it can contain values of any type. The parentheses around ! and := are needed because these are operators, rather than ordinary functions.

*** For and While Loops

We use the Random module as a source of randomness and permuate an array with a for loop:

#+BEGIN_SRC ocaml
  let permute array =
    let length = Array.length array in
    for i = 0 to length - 2 do
      (* pick a `j` to swap with *)
      let j = i + Random.int (length - i) in
      (* swap `i` and `j` *)
      let tmp = array.(i) in
      array.(i) <- array.(j);
      array.(j) <- tmp
    done
  ;;

  let ar = Array.init 10 ~f:(fun i -> i);;
  permute ar;;
  (* [|3; 9; 1; 6; 4; 2; 5; 8; 7; 0|] *)
#+END_SRC

From a syntactic perspective, you should note the keywords that distinguish a for loop:

=for=, =to=, =do=, and =done=.

Let's look at =while= loops.

#+BEGIN_SRC ocaml :exports both
  let find_first_negative_entry arr =
    let pos = ref 0 in
    while !pos < Array.length arr && arr.(!pos) >= 0 do
      pos := !pos + 1
    done;
    if !pos = Array.length arr then None else Some !pos
  ;;
#+END_SRC

#+RESULTS:
: val find_first_negative_entry : int array -> int option = <fun>

#+BEGIN_SRC ocaml :exports both
  find_first_negative_entry [| 0;1;2;3;4;5;3 |];;
#+END_SRC

#+RESULTS:
: - : int option = None

#+BEGIN_SRC ocaml :exports both
  find_first_negative_entry [| 1;3;-5;10;95;-4 |];;
#+END_SRC

#+RESULTS:
: - : int option = Some 2

As a side note, the preceding code takes advantage of the fact that &&, OCaml’s And operator, short-circuits. In particular, in an expression of the form expr1 && expr2, expr2 will only be evaluated if expr1 evaluated to true /(just like JS)/.

Notice how, when we change the code, we get an out of bounds error:

#+BEGIN_SRC ocaml :exports both
  let find_first_negative_entry array =
    let pos = ref 0 in
    while
      let pos_is_good = !pos < Array.length array in
      let element_is_non_negative = array.(!pos) >= 0 in
      pos_is_good && element_is_non_negative
    do
      pos := !pos + 1
    done;
    if !pos = Array.length array then None else Some !pos
  ;;

  let arr = [|1;2;0;3|];;
  find_first_negative_entry arr;;
#+END_SRC

#+RESULTS:
: Exception: Invalid_argument "index out of bounds".

The or operator =||= short circuits as well.


** A Complete Program

Let's create a standalone program now. This program will sum up a list of numbers read in from standard input.

The program is contained in [[file:sum.ml][sum.ml]] (located in this repository).

#+BEGIN_SRC ocaml
  #require "Core";;
  open Core;;

  let rec read_and_acc acc =
    let line = In_channel.input_line In_channel.stdin in
    match line with
    | None -> acc
    | Some x -> read_and_acc (acc +. Float.of_string x)

  let () =
    printf "Total: %F\n" (read_and_acc 0.)
#+END_SRC

*** Compiling and Running

We compile with =corebuild=, a small wrapper on top of /ocamlbuild/, a build tool that ships with the OCaml compiler.

It comes installed with Core.

=$ corebuild sum.native=

The =.native= suffix indicates that we're building a native-code executable (see Chapter 4). It creates a file in the same directory called =sum.native=.

This file is executable; to run it do =./sum.native=.


* Chapter 2: Variables & Functions

** Variables

#+BEGIN_QUOTE
Every variable binding has a scope, which is the portion of the code that can refer to that binding. When using utop, the scope of a top-level let binding is everything that follows it in the session. When it shows up in a module, the scope is the remainder of that module.
#+END_QUOTE

let can also be used to create a variable binding whose scope is limited to a particular expression, using the following syntax:

=let <variable> = <expr1> in <expr2>=

Let's practice:

#+BEGIN_SRC ocaml
  let languages = "OCaml,JavaScript,Brainfuck,C";;

  let dashed_langs =
    let languages = String.split languages ~on:',' in
    String.concat ~seq:"-" languages
  ;;

  dashed_langs;;
  (* val dashed_langs : string = "OCaml-Perl-C++-C" *)
#+END_SRC

Notice how =languages= inside =dashed_langs= is different than it is outside the expression.

A let binding in an inner scope can *shadow*, or /hide/, the definition from an outer scope.

*** Pattern Matching and =let=

=let= bindings support the use of /patterns/ on the lefthand side.

#+BEGIN_SRC ocaml
  let (ints, strings) =
    List.unzip [(1,"one"); (2,"two"); (3,"three")];;

  (* val ints : int list = [1; 2; 3]
   ,* val strings : string list = ["one"; "two"; "three"] *)
#+END_SRC

=List.unzip= converts a list of tuple pairs into a pair of lists.

A /pattern/ is essentially a description of the shape of a data structure, where some components are identifiers to be bound.

Using a pattern in a let binding makes the most sense for a pattern that is /irrefutable/, i.e., where any value of the type in question is guaranteed to match the pattern. Tuple and record patterns are irrefutable, /but list patterns are not/.

Therefore with lists we =match= to find patterns, instead of destructuring (is this true? my own interpretation).









